<?php

  $pagebase="<a href='http://www.xulplanet.com/tutorials/'>Tutorials</a> &gt; " .
    "<a href='http://www.xulplanet.com/tutorials/xultu/'>XUL Tutorial</a>";
  $pagetitle="8.3 - Manipulating RDF Datasources";
  $customsidebar = "xultu-sidebar.php";



  include "../../lib/header.php";
 ?>


<div class="navlinks-pnc">

  <a class="prevlink" title="8.2 - XPCOM Examples"
     href="xpcomex.html">Previous</a>


  <a class="nextlink" title="8.4 - Using the Clipboard"
     href="clipboard.html">Next</a>

</div>



<h2>Manipulating RDF Datasources</h2>

<P>
This section explains how to manipulate RDF with a script.
</P>

<H3>RDF Datasources with XPCOM</H3>

<P>
Templates can be used to extract data from an RDF datasource and build content
based on that data. However, the datasources can be examined from a script.
You can get the datasource from an element built from a template, and pick out
individual resources from it. This also allows you to modify the datasource.
</P>

<P>
The XPCOM interface to RDF involves a number of interfaces. The following lists
some of the interfaces invloved:
</P>

<TABLE BORDER=1>
  <TR>
    <TD>nsIRDFService</TD>
    <TD>A global RDF service. It is used to generate resource objects that can
        uniquely identify a resource within an RDF data source.</TD>
  </TR>
  <TR>
    <TD>nsIRDFDataSource</TD>
    <TD>An RDF datasource, either a built-in one or one from an RDF file.
        Methods allow you to get and set values.</TD>
  </TR>
  <TR>
    <TD>nsIRDFContainer</TD>
    <TD>A container node within an RDF data source. Methods allow you to
        add and remove resources.</TD>
  </TR>
  <TR>
    <TD>nsIRDFContainerUtils</TD>
    <TD>This interface has some handy container methods to create Seq, Bag and
        Alt resources.</TD>
  </TR>
</TABLE>

<DIV CLASS="task">

<P>
In the find files dialog, we could implement the ability to store the most
recently searched for items. The search textbox could be replaced by an
editable drop-down that contains a list of items that were recently searched
for. We will add this capability now.
</P>

<P>
This will really only work if the dialog has access to a location on disk where
the recent search items list can be stored. The most likely places for this
are the user's profile directory or a directory the user chooses themselves.
Although we won't do that here, the user's profile directory can be retrieved
using the '@mozilla.org/file/directory_service' component. To simplify the
example, we'll just put a file path directly in the XUL in a
<SPAN CLASS="attrib">datasources</SPAN> attribute.
</P>

<P>
We could store the recent searches list in a plain text file. However, we can use
RDF which already has the ability to read and write its data and update a widget
generated from a template automatically. First, the changes to the XUL file. We'll
replace the textbox with an editable drop-down list. Replace the value of the
<SPAN CLASS="attrib">datasources</SPAN> attribute with a suitable path. (The file
should exist already).
</P>


<DIV CLASS="sample"><PRE>&lt;menulist id="find-text" flex="1" style="min-width: 15em;"
          editable="true"
          datasources="file:///mozilla/recents.rdf"
          ref="http://www.xulplanet.com/rdf/recent/all"&gt;
  &lt;template&gt;
    &lt;menupopup&gt;
      &lt;menuitem label="rdf:http://www.xulplanet.com/rdf/recent#Label" uri="rdf:*"/&gt;
    &lt;/menupopup&gt;
  &lt;/template&gt;
&lt;/menulist&gt;</PRE></DIV>



</DIV>

<P>
All XUL elements that have their children generated by a template have a
<SPAN CLASS="attrib">database</SPAN> property that refers to a
nsIRDFDataSource object. This object can then be used to read from and
modify the data source used. The <SPAN CLASS="attrib">database</SPAN>
property is placed on the element that has the
<SPAN CLASS="attrib">datasources</SPAN> attribute. This will typically be
a <A CLASS="tag" HREF="/references/elemref/ref_tree.html">tree</A> or, as is the case here, a
<A CLASS="tag" HREF="/references/elemref/ref_menulist.html">menulist</A> element.
</P>

<P>
The <SPAN CLASS="attrib">database</SPAN> property contains a list (actually an
nsISimpleEnumerator) of each of the datasources that were specified in the
<SPAN CLASS="attrib">datasources</SPAN> attribute. That means that we need to
iterate over each element, even if there is only one. The following example
shows how to do this, assuming only one datasource exists:
</P>


<DIV CLASS="sample"><PRE>var dsource;
var menulist=document.getElementById("find-text");
var sources=menulist.database.GetDataSources();

if (sources.hasMoreElements()){
  dsource=sources.getNext();
}
dsource=dsource.QueryInterface(Components.interfaces.nsIRDFDataSource);</PRE></DIV>



<P>
First, we get a reference to a menulist, which here has an
<SPAN CLASS="attrib">id</SPAN> of 
<SPAN CLASS="aval">find-text</SPAN>. Next we get the list of datasources from
the menulist. The nsISimpleEnumerator interface has two methods (it is similar
to Java's Enumeration interface). We loop through the elements in the
enumeration and, because we assume there is only one, we'll just get it with the
getNext method. Finally, we'll call QueryInterface to ensure that it is an
nsIRDFDataSource.
</P>

<DIV CLASS="task">

<P>
We'll use code similar to this to create the recent searches list. First,
however, let's initialize the components that we want to use. We'll need
three components. The interface nsIRDFService will be used to create resource
objects. The interface nsIRDFContainer will be used to add resources to the
data source. The third interface, nsIRDFContainerUtils will be used only when
the recent searches list is first used, to create the root node. In a script
file (findfile.js), add the following code to the top of it. This will be
executed when the find files dialog is loaded.
</P>


<DIV CLASS="sample"><PRE>const RDFC = '@mozilla.org/rdf/container;1';
RDFC = Components.classes[RDFC].createInstance(Components.interfaces.nsIRDFContainer);

const RDFCUtils = '@mozilla.org/rdf/container-utils;1';
RDFCUtils = Components.classes[RDFCUtils].getService(Components.interfaces.nsIRDFContainerUtils);

const RDF = '@mozilla.org/rdf/rdf-service;1';
RDF = Components.classes[RDF].getService(Components.interfaces.nsIRDFService);</PRE></DIV>



<P>
This code will create the three services that we need to use. The syntax is
similar to other XPCOM object creation code. The first three lines get a
reference to an nsIRDFContainer object. Next, we perform a similar operation
to get the nsIRDFContainerUtils object. Finally, we repeat again for the
nsIRDFService.
</P>

<P>
Next, we create an initialize function, which we'll call in the
<SPAN CLASS="attrib">onload</SPAN> handler of the window. It will be executed
when the window is displayed. Within this code, we'll add code to
initialize the RDF objects we created above.
</P>


<DIV CLASS="sample"><PRE><B>findfile.xul:</B>

&lt;window <SPAN STYLE="color:red;">onload="initSearchList()"</SPAN> ... &gt;

<B>findfile.js:</B>

var dsource;

function initSearchList()
{
  var recentlist=document.getElementById("find-text");
  var sources=recentlist.database.GetDataSources();
  var rootnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all");
  
  while (sources.hasMoreElements()){
    try {
      dsource=sources.getNext();
      dsource=dsource.QueryInterface(Components.interfaces.nsIRDFDataSource);
  
      RDFC.Init(dsource,rootnode);
    } catch (e) {
      RDFCUtils.MakeSeq(dsource,rootnode);
      RDFC.Init(dsource,rootnode);
    }
  }
}</PRE></DIV>



<P>
Let's break down the initSearchList function:
</P>

<UL>
  <LI><PRE>var recentlist=document.getElementById("find-text");
var sources=recentlist.database.GetDataSources();</PRE>
      First, we get a reference to the <A CLASS="tag" HREF="/references/elemref/ref_menulist.html">menulist</A>
      element that has the datasource on it. It has a
      <SPAN CLASS="attrib">database</SPAN> property that holds the datasources
      that are present. We get a reference to the available datasources
      and assign it to the variable sources.</LI>
  <LI><PRE>var rootnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all");</PRE>
      A resource object is generated with the given URI. This will be the
      root resource and will be an RDF <SPAN CLASS=" tag">Seq</SPAN> element
      that holds a list of resources, one for each item in the recent searches
      list. This function does not get anything from the datasource, it only
      converts the URI into a resource identifier. Instead of hard-coding the
      URI, we could also get it from the <SPAN CLASS="attrib">ref</SPAN>
      attribute.</LI>
  <LI><PRE>while (sources.hasMoreElements()){
try {
  dsource=sources.getNext();
  dsource=dsource.QueryInterface(Components.interfaces.nsIRDFDataSource);</PRE>
      Next, we loop over each datasource to get the right one.</LI>
  <LI><PRE>RDFC.Init(dsource,rootnode);</PRE>
      This function initializes the RDF Container (the nsIRDFContainer
      interface) with the datasource and the root node. Later, we can use the
      container object to add new resources inside the container. We'll need
      to do this to add a searched item to the datasource. An error will occur
      if the datasource or root node does not exist (for example, if the RDF
      file was not found). The code was put into a try-catch block to catch
      the error.</LI>
  <LI><PRE>} catch (e){
  RDFCUtils.MakeSeq(dsource,rootnode);
  RDFC.Init(dsource,rootnode);
}</PRE>
      If an error occured, this is most likely because the root node did not
      exist. To create it, we call the method MakeSeq of the nsIRDFContainerUtils
      interface. Similar functions exist for creating bags and alts. (MakeBag and
      MakeAlt). We then try initializing the container again.</LI>
</UL>

<P>
The interface nsIRDFService contains a method GetResource that creates a
resource object for us, from the string passed in as an argument. This method
does not get the value of anything, it simply converts a string into a
resource object that can be used to get the value from the datasource. The
RDF interfaces do not use strings but instead use resources to refer to
things. The value returned by GetResource is of the type nsIRDFResource.
</P>

<P>
Now that the objects have been initialized, we can add and remove information
from the datasource. There are two methods needed depending on whether you
want to add a resource to a container or add an assertion from one resource
to another. These two cases correspond to adding a bookmark and adding a
property such as the title or URL to a bookmark.
</P>

<P>
We'll add a new entry to the searched for items list when the user clicks the
Find button. We'll oversimplify it a bit in several ways. For one, we won't
bother checking for duplicate entries. Second, we won't concern ourselves about
limiting the length of the list.
</P>

<P>
Let's add another function that is called from within the doFind function.
</P>


<DIV CLASS="sample"><PRE>function doFind()
{
  <SPAN STYLE="color:red;">var recentlist=document.getElementById("find-text");
  var fldval=recentlist.value;

  addSearchedItem(fldval);</SPAN>

.
.
.</PRE></DIV>



<P>
This code gets the value entered into the menulist's textbox. We pass the
text to the function addSearchedItem which will be defined next.
</P>


<DIV CLASS="sample"><PRE>function addSearchedItem(txt)
{
  var newnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all/item"+(RDFC.GetCount()+1));
  var labelprop=RDF.GetResource("http://www.xulplanet.com/rdf/recent#Label");
  var newvalue=RDF.GetLiteral(txt);
  
  dsource.Assert(newnode,labelprop,newvalue,true);
  RDFC.InsertElementAt(newnode,1,true);
  
  dsource.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource).Flush();
} </PRE></DIV>



<P>
This code does three things, it adds a new resource, it adds a new assertion
which holds the value, and then it writes out the modified datasource. Let's
break down the code:
</P>

<UL>
  <LI><PRE>var newnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all/item"+(RDFC.GetCount()+1));</PRE>
      This line creates a resource object for the resource we'll be adding.
      The function GetCount returns a count of the number of resources that
      exist in the container already. This allows us to generate a unique
      URI. We could also call GetAnonymousResource (instead of GetResource)
      which takes no parameters and generates a random unique URI.</LI>
  <LI><PRE>var labelprop=RDF.GetResource("http://www.xulplanet.com/rdf/recent#Label");</PRE>
      We'll be setting the Label property of the resource to the text that was
      recently searched for. You could use any property name (and URL) as long as
      it's consistent. You'll notice that it has the same value as the
      <SPAN CLASS="attrib">label</SPAN> attribute of the
      <A CLASS="tag" HREF="/references/elemref/ref_menuitem.html">menuitem</A> element added to the XUL earlier.</LI>
  <LI><PRE>var newvalue=RDF.GetLiteral(txt);</PRE>
      The GetLiteral function generates a RDF string object that will hold
      the text the user searched for, which was passed in through the txt
      argument. We don't use GetResource here because we are assigning a value
      to a resource.</LI>
  <LI><PRE>dsource.Assert(newnode,labelprop,newvalue,true);</PRE>
      This line will add an assertion to the RDF datasource. In this case, it
      says that the 'Label' of the resource 'http://www.xulplanet.com/rdf/recent/all/itemX' is
      the literal object that was created in the previous line, where X is
      the number returned from the GetCount function. However, this is only
      half of what needs to be done. We still need to say that the resource
      is one of the recent items.</LI>
  <LI><PRE>RDFC.InsertElementAt(newnode,1,true);</PRE>
      This line adds the resource to the container. Here, we insert it at
      position 1. (Not that the first element is 1 and not 0.) We could insert
      it anywhere, or call AppendElement instead to add it to the end. The
      menulist template will now detect the new resource, and will have an
      extra row in the list.</LI>
  <LI><PRE>dsource.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource).Flush();</PRE>
      Finally, we write the datasource to disk using the Flush function. This
      function is not a part of the nsIRDFDataSource interface, so we have to
      call QueryInterface to convert the datasource into the right interface,
      nsIRDFRemoteDataSource, first.</LI>
</UL>

<DIV CLASS="note">
Not all datasources can be modified. All datasources loaded from file and
resource URLs can be written to as well as some of the internal datasources.
</DIV>

<P>
If you open the find files dialog now and enter some text, and press Find, you
will find that the text appears as one of the choices in the drop-down.
Even if you exit and reload, the text will remain in the drop-down.
</P>

</DIV>

<P>
In order to check for duplicate entries, we could check the existing resources,
by using the functions hasAssertion or GetAllResources of the interface
nsIRDFDataSource.
</P>
 
<HR>
<P>
<A HREF="clipboard.html">(Next)</A>
Next, we'll see how to access the system clipboard for copy and paste operations.

</P>
<P>Find files example so far:
<A HREF='examples/findfile/findfile-rdfscript.xul.txt'>Source</A>
<A HREF="examples/findfile/findfile-rdfscript.xul" ONCLICK="window.open('examples/findfile/findfile-rdfscript.xul','xulff','chrome,resizable'); return false;">View</A>
<P>Note that you will have to load the file from a chrome URL to see the recent files list in use.
</P>
<div class="navlinks-pnc">

  <a class="prevlink" title="8.2 - XPCOM Examples"
     href="xpcomex.html">Previous</a>


  <a class="nextlink" title="8.4 - Using the Clipboard"
     href="clipboard.html">Next</a>

</div>


<?php include "../../comments/comments.php"; ?>

<?php include "../../lib/footer.php" ?>



