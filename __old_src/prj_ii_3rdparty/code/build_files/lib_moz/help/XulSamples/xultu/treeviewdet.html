<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<link rel="stylesheet" title="Default Style" href="styles/default/main.css" type="text/css">
<link rel="stylesheet" href="styles/default/xultu.css" type="text/css">


<link rel="stylesheet" href="styles/default/xultu-print.css" type="text/css" media="print">


<link rel="home"   href="http://www.xulplanet.com/"            title="http://www.XulPlanet.com/">
<link rel="search" href="http://www.xulplanet.com/cgi-bin/search/search.cgi" title="Search XulPlanet">
<link rel="author" href="http://www.xulplanet.com/ndeakin" title="Neil Deakin">
 <link rel="up" href="http://www.xulplanet.com/tutorials/" title="Up"> 
 <link rel="first" href="intro.html" title="First"> 
 <link rel="last" href="end.html" title="Last"> 

 <link rel="prev" href="treeview.html"> 
 <link rel="next" href="treeboxobject.html"> 

<meta name="Description" content="Step by step tutorial of the XML User Interface Language">

<title>XulPlanet.com - Tree View Details</title>

</head>
<body>

<div id="header">
  <a href="http://www.xulplanet.com/">
    <img id="logo" src="images/xulplanet.png" width="215" height="65" alt="XUL Planet">
  </a>

<div id="locationlinks">
  <a href="http://www.xulplanet.com/">Home</a> &gt;

  <a href="http://www.xulplanet.com/tutorials/">Tutorials</a> :


  <a href="index.html">XUL Tutorial</a> :



 8.5 - Tree View Details 
</div>



</div>



<hr class="edgesplit">

<div id="sidebar">

<div id="search">
  <form action="/cgi-bin/search/search.cgi" method="get">
    Search:<br>
    <input id="search-box" name="Terms" type="text">
    <input type="submit" value="Go">
  </form>
</div>

<hr>

<ul class="sidebar-section-links">
  <li><a href="http://www.xulplanet.com/tutorials/xultu/allofit.zip">Single Document Version</a></li>
  <li><a href="http://www.xulplanet.com/tutorials/xultu/xultu.zip">Download the XUL Tutorial</a><br></li>
  <li><a href="http://www.xulplanet.com/references/elemref/">Element Reference</a></li>
  <li><a href="http://www.xulplanet.com/references/elemref/quickref.html">Quick Reference</a><br></li>
  <li><a href="keyref.html">Key Code Reference</a></li>
  <li><a href="templateex.html">Template Syntax Examples</a></li>
</ul>

<hr>



<OL id="sidebar-docs-index">
  <LI class="sidebar-section-title">Introduction
  <OL>
    <LI> <A HREF="intro.html">Introduction</A></LI>
    <LI> <A HREF="xulfile.html">XUL Structure</A></LI>
    <LI> <A HREF="chromeurl.html">The Chrome URL</A></LI>
    <LI> <A HREF="packaging.html">Contents.rdf Files</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Simple Elements
  <OL>
    <LI> <A HREF="window.html">Creating a Window</A></LI>
    <LI> <A HREF="buttons.html">Adding Buttons</A></LI>
    <LI> <A HREF="textimage.html">Adding Labels and Images</A></LI>
    <LI> <A HREF="inputs.html">Input Controls</A></LI>
    <LI> <A HREF="lists.html">List Controls</A></LI>
    <LI> <A HREF="progress.html">Progress Meters</A></LI>
    <LI> <A HREF="htmlelem.html">Adding HTML Elements</A></LI>
    <LI> <A HREF="springs.html">Using Spacers</A></LI>
    <LI> <A HREF="advbtns.html">More Button Features</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">The Box Model
  <OL>
    <LI> <A HREF="boxes.html">The Box Model</A></LI>
    <LI> <A HREF="boxstyle.html">Element Positioning</A></LI>
    <LI> <A HREF="boxdet.html">Box Model Details</A></LI>
    <LI> <A HREF="titledbox.html">Groupboxes</A></LI>
    <LI> <A HREF="boxfinal.html">Adding More Elements</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">More Layout Elements
  <OL>
    <LI> <A HREF="stacks.html">Stacks and Decks</A></LI>
    <LI> <A HREF="bulletins.html">Stack Positioning</A></LI>
    <LI> <A HREF="tabpanel.html">Tabboxes</A></LI>
    <LI> <A HREF="grids.html">Grids</A></LI>
    <LI> <A HREF="cpanels.html">Content Panels</A></LI>
    <LI> <A HREF="splitter.html">Splitters</A></LI>
    <LI> <A HREF="scroll.html">Scroll Bars</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Toolbars and Menus
  <OL>
    <LI> <A HREF="toolbar.html">Toolbars</A></LI>
    <LI> <A HREF="menubar.html">Simple Menu Bars</A></LI>
    <LI> <A HREF="advmenu.html">More Menu Features</A></LI>
    <LI> <A HREF="popups.html">Popup Menus</A></LI>
    <LI> <A HREF="menuscroll.html">Scrolling Menus</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Events and Scripts
  <OL>
    <LI> <A HREF="events.html">Adding Event Handlers</A></LI>
    <LI> <A HREF="advevents.html">More Event Handlers</A></LI>
    <LI> <A HREF="keyshort.html">Keyboard Shortcuts</A></LI>
    <LI> <A HREF="focus.html">Focus and Selection</A></LI>
    <LI> <A HREF="commands.html">Commands</A></LI>
    <LI> <A HREF="commandupdate.html">Updating Commands</A></LI>
    <LI> <A HREF="broadob.html">Broadcasters and Observers</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Document Object Model
  <OL>
    <LI> <A HREF="dom.html">Document Object Model</A></LI>
    <LI> <A HREF="dommodify.html">Modifying a XUL Interface</A></LI>
    <LI> <A HREF="domlists.html">Manipulating Lists</A></LI>
    <LI> <A HREF="boxobject.html">Box Objects</A></LI>
    <LI> <A HREF="xpcom.html">XPCOM Interfaces</A></LI>
    <LI> <A HREF="xpcomex.html">XPCOM Examples</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Trees
  <OL>
    <LI> <A HREF="trees.html">Trees</A></LI>
    <LI> <A HREF="advtrees.html">More Tree Features</A></LI>
    <LI> <A HREF="seltree.html">Tree Selection</A></LI>
    <LI> <A HREF="treeview.html">Custom Tree Views</A></LI>
    <LI> <SPAN CLASS="currentpage">Tree View Details</SPAN></LI>
    <LI> <A HREF="treeboxobject.html">Tree Box Objects</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">RDF and Templates
  <OL>
    <LI> <A HREF="intrordf.html">Introduction to RDF</A></LI>
    <LI> <A HREF="templates.html">Templates</A></LI>
    <LI> <A HREF="treetempl.html">Trees and Templates</A></LI>
    <LI> <A HREF="datasrc.html">RDF Datasources</A></LI>
    <LI> <A HREF="advrules.html">Advanced Rules</A></LI>
    <LI> <A HREF="persist.html">Persistent Data</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Skins and Locales
  <OL>
    <LI> <A HREF="style.html">Adding Style Sheets</A></LI>
    <LI> <A HREF="treestyle.html">Styling a Tree</A></LI>
    <LI> <A HREF="defskin.html">Modifying the Default Skin</A></LI>
    <LI> <A HREF="cskin.html">Creating a Skin</A></LI>
    <LI> <A HREF="locale.html">Localization</A></LI>
    <LI> <A HREF="locprops.html">Property Files</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Bindings
  <OL>
    <LI> <A HREF="introxbl.html">Introduction to XBL</A></LI>
    <LI> <A HREF="xblcontent.html">Anonymous Content</A></LI>
    <LI> <A HREF="xblatin.html">XBL Attribute Inheritance</A></LI>
    <LI> <A HREF="xblprops.html">Adding Properties</A></LI>
    <LI> <A HREF="xblmethods.html">Adding Methods</A></LI>
    <LI> <A HREF="xblevents.html">Adding Event Handlers</A></LI>
    <LI> <A HREF="xblinherit.html">XBL Inheritance</A></LI>
    <LI> <A HREF="xblex.html">XBL Example</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Specialized Window Types
  <OL>
    <LI> <A HREF="featwin.html">Features of a Window</A></LI>
    <LI> <A HREF="dialogs.html">Creating Dialogs</A></LI>
    <LI> <A HREF="filedialog.html">Open and Save Dialogs</A></LI>
    <LI> <A HREF="wizard.html">Creating a Wizard</A></LI>
    <LI> <A HREF="advwiz.html">More Wizards</A></LI>
    <LI> <A HREF="overlay.html">Overlays</A></LI>
    <LI> <A HREF="crosspov.html">Cross Package Overlays</A></LI>
  </OL>
  </LI>
  <LI class="sidebar-section-title">Installation
  <OL>
    <LI> <A HREF="xpinstall.html">Creating an Installer</A></LI>
    <LI> <A HREF="xpiscript.html">Install Scripts</A></LI>
    <LI> <A HREF="xpiadv.html">Additional Install Features</A></LI>
  </OL>
</OL>

</div>



<div id="content">

<div class="navlinks-pnc">

  <a class="prevlink" title="8.4 - Custom Tree Views"
     href="treeview.html">Previous</a>


  <a class="nextlink" title="8.6 - Tree Box Objects"
     href="treeboxobject.html">Next</a>

</div>

<div class="xultu-content">

<h2>Tree View Details</h2>

<P>
This section will describe some more features of tree views.
</P>

<H3>Creating a Hierarchical Custom View</H3>

<P>
In the last section, we created a simple tree view that implemented only a minimum
amount of functionality. Next, let's look at some additional functions that views
may implement. Here, we will examine how to create a hierarchical set of items
using the view. This is a fairly tricky process as it involves keeping track of
which items have children and also which rows are open and closed.
</P>

<P>
Every row in the tree has a nesting level. The topmost rows are at level 0, the
children of those rows are at level 1, their children at level 2 and so on. The
tree will query the view for each row by calling its getLevel method to find out
the level of that row. The view will need to return 0 for the outermost rows and
higher values for inner rows. The tree will use this information to determine the
hierarchical structure of the rows.
</P>

<P>
In addition to the getLevel method, there is a hasNextSibling function which, given
a row, should return true if there is another row afterwards at the same level.
This function is used, specifically, to draw the nesting lines along the side of
the tree.
</P>

<P>
The getParentIndex method is expected to return the parent row of a given row, that
is, the row before it with a lower nesting value. All of these methods must be
implemented by the view for children to be handled properly.
</P>

<P>
There are also three functions, isContainer, isContainerEmpty and isContainerOpen
that are used to handle a parent item in the tree. Naturally, the isContainer
method should return true if a row is a container and might contain children. The
isContainerEmpty method should return true if a row is an empty container, for
instance, a directory with no files in it. The view is required to keep track of
which items are opened and closed, so the isContainerOpen method is used to
determine this. The tree will call this method to determine which containers are
open and which are closed. Note that the tree will call neither isContainerEmpty
nor isContainerOpen for rows that are not containers as indicated by the return
value of the isContainer method.
</P>

<P>
A container may be rendered differently than a non-container. For instance, a
container may have a folder icon beside it. A style sheet may be used to style
items based on various properties such as whether a row is open. This is described
in a <A HREF="treestyle.html">later section</A>. A non-empty container will be
displayed with a twisty next to it so that the user may open and close the row to
see child items. Empty containers will not have a twisty, but will still be treated
like a container.
</P>

<P>
When the user clicks the twisty to open a row, the tree will call the view's
toggleOpenState method. The view should then perform any necessary operations to
retrieve the child rows and then update the tree with the new rows.
</P>

<P>
Here is a review of the methods needed to implement hierarchical views:
</P>


<DIV CLASS="sample"><PRE>
getLevel(row)
hasNextSibling(row, afterIndex)
getParentIndex(row)
isContainer(row)
isContainerEmpty(row)
isContainerOpen(row)
toggleOpenClose(row)</PRE></DIV>



<P>
The afterIndex argument to hasNextSibling function is used as optimization to only
start looking for the next sibling after that point. For instance, the caller might
already know where the next sibling might possibly be. Imagine a situation where a
row had subrows and those subrows had child rows of their own and several are open.
In could take a while in some implementations to determine what next sibling's row
index in this case.
</P>

<P>
Let's put this together into a simple example that takes an array and constructs a
tree from it. We'll examine it piece by piece.
</P>


<DIV CLASS="sample"><PRE>
&lt;window onload="init();"
        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;

&lt;tree id="elementList" flex="1"&gt;
  &lt;treecols&gt;
    &lt;treecol id="element" label="Element" primary="true" flex="1"/&gt;
  &lt;/treecols&gt;
  &lt;treechildren/&gt;
&lt;/tree&gt;

&lt;/window&gt;</PRE></DIV>



<P>
We use a simple tree here with no data in the
<A CLASS="tag" HREF="elemref/ref_treechildren.html">treechildren</A>. The 'init' function is called when the
window is loaded to initialize the tree. It simply sets the custom view by
retrieving the tree and setting its 'view' property. We will define 'treeView'
next.


<DIV CLASS="sample"><PRE>
function init() {
  document.getElementById("elementList").view = treeView;
}</PRE></DIV>



<P>
The custom tree view will need to implement a number of methods, of which the
important ones will be examined individually. This tree will only support a single
parent level with an inner child level, but it could be extended to support
additional levels without too much effort. First we'll define two structures to
hold the data for the tree, the first will hold a map between parents and the
children that may contain, and the second will hold an array of the visible items.
Remember that a custom view must keep track of which items are visible itself.
</P>


<DIV CLASS="sample"><PRE>
var treeView = {
  childData : {
    Solids: ["Silver", "Gold", "Lead"],
    Liquids: ["Mercury"],
    Gases: ["Helium", "Nitrogen"]
  },

  visibleData : [
    ["Solids", true, false],
    ["Liquids", true, false],
    ["Gases", true, false]
  ],</PRE></DIV>



<P>
The childData structure holds an array of the children for each of the three
parent nodes. The visibleData array begins with only three items visible, the three
top level items. Items will be added and removed from this array when items are
opened or closed. Essentially, when a parent row is opened, the children will be
taken from the childData map and inserted into the visibleData array. For example,
if the Liquids row was opened, the corresponding array from childData, which in
this case contains only the single Mercury child, will be inserted into the
visibleData array after Liquids but before Gases. This will increase the array
size by one. The two booleans in each row in the visibleData structure indicate
whether a row is a container and whether it is open respectively. Obviously, the
new inserted child items will have both values set to false.
</P>

<P>
Next, we need to implement the tree view interface. First, the simple functions:
</P>


<DIV CLASS="sample"><PRE>
  treeBox: null,
  selection: null,

  get rowCount()                     { return this.visibleData.length; },
  setTree: function(treeBox)         { this.treeBox = treeBox; },
  getCellText: function(idx, column) { return this.visibleData[idx][0]; },
  isContainer: function(idx)         { return this.visibleData[idx][1]; },
  isContainerOpen: function(idx)     { return this.visibleData[idx][2]; },
  isContainerEmpty: function(idx)    { return false; },
  isSeparator: function(idx)         { return false; },
  isSorted: function()               { return false; },
  isEditable: function(idx, column)  { return false; },</PRE></DIV>



<P>
The rowCount function will return the length of the visibleData array. Note that
it should return the current number of visible rows, not the total. So, at first,
only three items are visible and the rowCount should be three, even though six rows
are hidden.
</P>

<P>
The setTree function will be called to set the tree's box object. The tree box
object is a specialized type of box object specific to trees and will be examined
in detail in the next section. It is used to aid in drawing the tree. In this
example, we will only need one function of the box object, to be able to redraw the
tree when items are added or removed.
</P>

<P>
The getCellText, isContainer and isContainerOpen functions just return the
corresponding element from the visibleData array. Finally, the remaining functions
can just return false since we don't need those features. If we had a row that had
no children we would want to implement the isContainerEmpty function so that it
returned true for those elements.
</P>


<DIV CLASS="sample"><PRE>
  getParentIndex: function(idx) {
    if (this.isContainer(idx)) return -1;
    for (var t = idx - 1; t >= 0 ; t--) {
      if (this.isContainer(t)) return t;
    }
  },</PRE></DIV>



<P>
The getParentIndex will need to find the parent of a given index. In our simple
example, there is only two levels, so we know that containers don't have parents,
so -1 is returned for these items. Otherwise, we just iterate backwards through
the rows looking for one that is a container. Next, the getLevel function.
</P>


<DIV CLASS="sample"><PRE>
  getLevel: function(idx) {
    if (this.isContainer(idx)) return 0;
    return 1;
  },</PRE></DIV>



<P>
The getLevel function is simple. It just returns 0 for container rows and 1 for
non-containers. If we wanted to add an additional level of children, those rows
would have a level of 2.
</P>


<DIV CLASS="sample"><PRE>
  hasNextSibling: function(idx, after) {
    var thisLevel = this.getLevel(idx);
    for (var t = idx + 1; t < this.visibleData.length; t++) {
      var nextLevel = this.getLevel(t)
      if (nextLevel == thisLevel) return true;
      else if (nextLevel < thisLevel) return false;
    }
  },</PRE></DIV>



<P>
The hasNextSibling function needs to return true if there is a row at the same
level after a given row. The code above uses a brute force method which simply
iterates over the rows looking for one, returning true if a row exists with the
same level and false once it finds a row that has a lower level. In this simple
example, this method is fine, but a tree with a larger set of data will want to
use a more optimal method of determining whether a later sibling exists.
</P>

<P>
The final function of note is toggleOpenState, which is the most complex. It needs
to modify the visibleItems array when a row is opened or closed.
</P>


<DIV CLASS="sample"><PRE>
  toggleOpenState: function(idx) {
    var item = this.visibleData[idx];
    if (!item[1]) return;

    if (item[2]) {
      item[2] = false;

      var thisLevel = this.getLevel(idx);
      var deletecount = 0;
      for (var t = idx + 1; t < this.visibleData.length; t++) {
        if (this.getLevel(t) > thisLevel) deletecount++;
        else break;
      }
      if (deletecount) {
        this.visibleData.splice(idx + 1, deletecount);
        this.treeBox.rowCountChanged(idx + 1, -deletecount);
      }
    }
    else {
      item[2] = true;

      var label = this.visibleData[idx][0];
      var toinsert = this.childData[label];
      for (var i = 0; i < toinsert.length; i++) {
        this.visibleData.splice(idx + i + 1, 0, [toinsert[i], false]);
      }
      this.treeBox.rowCountChanged(idx + 1, toinsert.length);
    }
  },</PRE></DIV>



<P>
First we will need to check if the row is a container. If not, the function just
returns since non-containers cannot be opened or closed. Since the third element
in the item array (with an index of 2) holds whether the row is open or not, we
use two code paths, the first to close a row and the second to open a row. Let's
examine each block of code, but let's look at the second block for opening a
row first.
</P>


<DIV CLASS="sample"><PRE>
      item[2] = true;

      var label = this.visibleData[idx][0];
      var toinsert = this.childData[label];
      for (var i = 0; i < toinsert.length; i++) {
        this.visibleData.splice(idx + i + 1, 0, [toinsert[i], false]);
      }
      this.treeBox.rowCountChanged(idx + 1, toinsert.length);</PRE></DIV>



<P>
The first line makes the row open in the array so that we will know the next
time the toggleOpenState function is called that the row will need to be closed
instead. Next, we look up the data in the childData map for the row. The result
is that 'toinsert' will be set to one of the child arrays, for example
["Silver", "Gold", "Lead"] if the Solids row is the one being opened. Next, we
use the array's splice function to insert a new row for each item. For Solids,
three items will be inserted.
</P>

<P>
Finally, the tree box's rowCountChanged function needs to be called. Recall
that treeBox is a tree box object and was set earlier by a call to the setTree
function. The tree box object will be created by the tree for you and you can
call its functions. In this case, we use the rowCountChanged function to inform
the tree that some rows were added to the underlying data. The tree will then
redraw the tree as needed and the result is that the child rows will appear inside
the container. The various other functions implemented above such as getLevel and
isContainer are used by the tree to determine how to draw the tree.
</P>

<P>
The rowCountChanged function takes two arguments, the index where the first row was
inserted and the number of rows to insert. In the code above we indicate that the
starting row is the value of 'idx' plus one, which will be the first child under
the parent. The tree will use this information and add space for the appropriate
number of rows and push the rows afterwards down. Make sure to pass the right
number or the tree might redraw incorrectly or try to draw more rows than
necessary.
</P>

<P>
The following code is used to delete rows when a row is closed.
</P>


<DIV CLASS="sample"><PRE>
      item[2] = false;

      var thisLevel = this.getLevel(idx);
      var deletecount = 0;
      for (var t = idx + 1; t < this.visibleData.length; t++) {
        if (this.getLevel(t) > thisLevel) deletecount++;
        else break;
      }
      if (deletecount) {
        this.visibleData.splice(idx + 1, deletecount);
        this.treeBox.rowCountChanged(idx + 1, -deletecount);
      }</PRE></DIV>



<P>
First, the item is set closed in the array. Then, we scan along the rows until
we come to one that is at the same level. All those that have a higher level will
need to be removed, but a row at the same level will be the next container which
should not be removed.
</P>

<P>
Finally, we use the splice function to remove the rows from the visibleData array
and call the rowCountChanged function to redraw the tree. When deleting rows, you
will need to supply a negative count of the number of rows to delete.
</P>

<P>
There are several other view functions we can implement but they don't need to
do anything in this example, so we can create functions that do nothing for those.
They are added near the end of the complete example, shown here:
</P>


<DIV CLASS="sample"><PRE>
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet href="chrome://global/skin/" type="text/css"?&gt;

&lt;window onload="init();"
        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;

&lt;tree id="elementList" flex="1"&gt;
  &lt;treecols&gt;
    &lt;treecol id="element" label="Element" primary="true" flex="1"/&gt;
  &lt;/treecols&gt;
  &lt;treechildren/&gt;
&lt;/tree&gt;

&lt;script&gt;
&lt;![CDATA[

var treeView = {
  childData : {
    Solids: ["Silver", "Gold", "Lead"],
    Liquids: ["Mercury"],
    Gases: ["Helium", "Nitrogen"]
  },

  visibleData : [
    ["Solids", true, false],
    ["Liquids", true, false],
    ["Gases", true, false]
  ],

  treeBox: null,
  selection: null,

  get rowCount()                     { return this.visibleData.length; },
  setTree: function(treeBox)         { this.treeBox = treeBox; },
  getCellText: function(idx, column) { return this.visibleData[idx][0]; },
  isContainer: function(idx)         { return this.visibleData[idx][1]; },
  isContainerOpen: function(idx)     { return this.visibleData[idx][2]; },
  isContainerEmpty: function(idx)    { return false; },
  isSeparator: function(idx)         { return false; },
  isSorted: function()               { return false; },
  isEditable: function(idx, column)  { return false; },

  getParentIndex: function(idx) {
    if (this.isContainer(idx)) return -1;
    for (var t = idx - 1; t >= 0 ; t--) {
      if (this.isContainer(t)) return t;
    }
  },
  getLevel: function(idx) {
    if (this.isContainer(idx)) return 0;
    return 1;
  },
  hasNextSibling: function(idx, after) {
    var thisLevel = this.getLevel(idx);
    for (var t = idx + 1; t < this.visibleData.length; t++) {
      var nextLevel = this.getLevel(t)
      if (nextLevel == thisLevel) return true;
      else if (nextLevel < thisLevel) return false;
    }
  },
  toggleOpenState: function(idx) {
    var item = this.visibleData[idx];
    if (!item[1]) return;

    if (item[2]) {
      item[2] = false;

      var thisLevel = this.getLevel(idx);
      var deletecount = 0;
      for (var t = idx + 1; t &lt; this.visibleData.length; t++) {
        if (this.getLevel(t) > thisLevel) deletecount++;
        else break;
      }
      if (deletecount) {
        this.visibleData.splice(idx + 1, deletecount);
        this.treeBox.rowCountChanged(idx + 1, -deletecount);
      }
    }
    else {
      item[2] = true;

      var label = this.visibleData[idx][0];
      var toinsert = this.childData[label];
      for (var i = 0; i &lt; toinsert.length; i++) {
        this.visibleData.splice(idx + i + 1, 0, [toinsert[i], false]);
      }
      this.treeBox.rowCountChanged(idx + 1, toinsert.length);
    }
  },

  getImageSrc: function(idx, column) {},
  getProgressMode : function(idx,column) {},
  getCellValue: function(idx, column) {},
  cycleHeader: function(col, elem) {},
  selectionChanged: function() {},
  cycleCell: function(idx, column) {},
  performAction: function(action) {},
  performActionOnCell: function(action, index, column) {},
  getRowProperties: function(idx, column, prop) {},
  getCellProperties: function(idx, column, prop) {},
  getColumnProperties: function(column, element, prop) {},
};

function init() {
  document.getElementById("elementList").view = treeView;
}

]]>&lt;/script&gt;

&lt;/window&gt;</PRE></DIV>



<HR>
<P>
<A HREF="treeboxobject.html">(Next)</A>
Next, we'll look in more detail at the tree box object.

</P>
</div>

<div class="navlinks-pnc">

  <a class="prevlink" title="8.4 - Custom Tree Views"
     href="treeview.html">Previous</a>


  <a class="nextlink" title="8.6 - Tree Box Objects"
     href="treeboxobject.html">Next</a>

</div>

</div>

<hr class="edgesplit">

<div id="copyblock">
  Copyright (C) 1999 - 2004 XulPlanet.com
</div>

</body>
</html>

